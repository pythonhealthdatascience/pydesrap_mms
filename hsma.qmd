---
title: "HSMA model"
---

This is code that was shared under an MIT Licence, with credit to: Sammi Rosser and Dan Chalk (2024) HSMA - the little book of DES (<https://github.com/hsma-programme/hsma6_des_book>).

Below is basic model including:

* Warm-up periods
* Priority-based queueing
* Resource unavailability
* Seeds
* Reneging
* Balking

It does not include:

* Multiple activities
* Branching paths
* Jockeying
* Variable arrival times

```{python}
import numpy as np
import pandas as pd
import plotly.express as px
import random
import simpy

class g:
    '''Global parameters.'''
    # Inter-arrival times
    patient_inter = 5

    # Activity times
    mean_n_consult_time = 6

    # Resource numbers
    number_of_nurses = 1

    # Simulation meta parameters
    sim_duration = 2880
    warm_up_period = 1440  # WARMUP - for no warm-up, set to 0
    number_of_runs = 10

class Exponential:
    '''Exponential distribution.'''
    def __init__(self, mean, random_seed = None):
        self.mean = mean
        self.rand = np.random.default_rng(random_seed)

    def sample(self, size = None):
        '''Generate sample.'''
        return self.rand.exponential(self.mean, size=size)

class Patient:
    '''Represents a patient.'''
    def __init__(self, p_id):
        self.id = p_id
        self.q_time_nurse = 0

class Model:
    '''Simulation model for a clinic.'''
    def __init__(self, run_number):
        # Create SimPy environment
        self.env = simpy.Environment()

        self.patient_counter = 0

        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)
        self.run_number = run_number

        # Create dataframe to store patient-level results
        self.results_df = pd.DataFrame()
        self.results_df['Patient ID'] = [1]
        self.results_df['Q Time Nurse'] = [0.0]
        self.results_df.set_index('Patient ID', inplace=True)

        # Attributes to store metrics
        self.mean_q_time_nurse = 0

        # Initialise distributions
        self.patient_inter_arrival_dist = Exponential(
            mean = g.patient_inter, random_seed = self.run_number*2)
        self.nurse_consult_time_dist = Exponential(
            mean = g.mean_n_consult_time, random_seed = self.run_number*4)

    def generator_patient_arrivals(self):
        '''Generates patient arrivals.''' 
        while True:
            self.patient_counter += 1
            p = Patient(self.patient_counter)
            self.env.process(self.attend_clinic(p))
            sampled_inter = self.patient_inter_arrival_dist.sample()
            yield self.env.timeout(sampled_inter)

    def attend_clinic(self, patient):
        '''Simulates patient journey through the clinic.'''
        # Start queueing and request nurse resource
        start_q_nurse = self.env.now
        with self.nurse.request() as req:
            yield req

            # Record time spent waiting
            end_q_nurse = self.env.now
            patient.q_time_nurse = end_q_nurse - start_q_nurse

            # Only save results if the warm up period has passed
            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, 'Q Time Nurse'] = (
                    patient.q_time_nurse
                )

            # Sample and pass time spent with nurse
            sampled_nurse_act_time = self.nurse_consult_time_dist.sample()
            yield self.env.timeout(sampled_nurse_act_time)

    def calculate_run_results(self):
        '''Calculates mean queuing time for the run.'''
        # WARM-UP: Remove dummy patient created when set up dataframe  #TODO: Check if can set up in different way so not issue?
        self.results_df.drop([1], inplace=True)
        self.mean_q_time_nurse = self.results_df['Q Time Nurse'].mean()

    def run(self):
        '''Executes the simulation run.'''
        # Start patient generator
        self.env.process(self.generator_patient_arrivals())

        # Run for specified duration + warm-up period
        self.env.run(until=(g.sim_duration + g.warm_up_period))

        # Tidy patient-level results and calculate averages
        self.calculate_run_results()

        # Return patient level results
        return (self.results_df)

class Trial:
    '''Manages multiple simulation runs.'''
    def __init__(self):
        self.df_trial_results = pd.DataFrame()
        self.df_trial_results['Run Number'] = [0]
        self.df_trial_results['Mean Q Time Nurse'] = [0.0]
        self.df_trial_results.set_index('Run Number', inplace=True)

    def calculate_means_over_trial(self):
        self.mean_q_time_nurse_trial = (
            self.df_trial_results['Mean Q Time Nurse'].mean()
        )

    def run_trial(self):
        '''Executes a trial with multiple runs.'''
        results_dfs = []

        # For specified number of replications
        for run in range(g.number_of_runs):
    
            # Run model
            my_model = Model(run)
            patient_level_results = my_model.run()
    
            # print(self.df_trial_results)

            # Record trial-level results
            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]

            # Tidy patient level-results and append to list
            patient_level_results = patient_level_results.round(2)
            patient_level_results['run'] = run
            results_dfs.append(patient_level_results)

        # Convert patient-level results to dataframe
        all_results_patient_level = pd.concat(results_dfs)

        # Calculate mean times
        self.calculate_means_over_trial()

        # Return trial-level results, patient-level results and mean queue time for nurse
        return (self.df_trial_results,
                all_results_patient_level,
                self.mean_q_time_nurse_trial)

    def print_trial_results(self):
        print('Trial Results')
        # Patient-level data
        # print (self.df_trial_results)
        print(f'Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes')

# Create an instance of the Trial class and run the trial
my_trial = Trial()
df_trial_results_warmup, all_results_patient_level_warmup, means_over_trial_warmup = my_trial.run_trial()

my_trial.print_trial_results()

# Run version without warm-up
g.warm_up_period = 0
my_trial = Trial()
df_trial_results, all_results_patient_level, means_over_trial = my_trial.run_trial()

# Results without warm-up
display(all_results_patient_level.head())
display(df_trial_results.round(2).head())

# Results with warm-up
display(all_results_patient_level_warmup.head())
display(df_trial_results_warmup.round(2).head())

# Plot warm-up v.s. no warm-up
df_trial_results = df_trial_results.reset_index()
df_trial_results['Warm Up'] = 'No Warm Up'
df_trial_results_warmup = df_trial_results_warmup.reset_index()
df_trial_results_warmup['Warm Up'] = 'With Warm Up'
fig = px.histogram(
    pd.concat([df_trial_results, df_trial_results_warmup]).round(2).reset_index(),
    x='Warm Up',
    color='Run Number', y='Mean Q Time Nurse',
    barmode='group',
    title='Average Queue Times per Run - With and Without Warmups')
fig.show()
```