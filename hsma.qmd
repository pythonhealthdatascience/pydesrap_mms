---
title: "HSMA model"
---

This code is adapted from: Sammi Rosser and Dan Chalk (2024) HSMA - the little book of DES (<https://github.com/hsma-programme/hsma6_des_book>).

```{python}
import itertools
from joblib import Parallel, delayed
import numpy as np
import pandas as pd
import plotly.express as px
import random
import simpy
import time


class g:
    '''Global parameters.'''
    # Inter-arrival times
    patient_inter = 5

    # Activity times
    mean_n_consult_time = 35

    # Resource numbers
    number_of_nurses = 9

    # Simulation meta parameters
    sim_duration = 600
    warm_up_period = 200
    number_of_runs = 5
    audit_interval = 5
    scenario_name = 0


class Exponential:
    '''Exponential distribution.'''
    def __init__(self, mean, random_seed = None):
        self.mean = mean
        self.rand = np.random.default_rng(random_seed)

    def sample(self, size = None):
        '''Generate sample.'''
        return self.rand.exponential(self.mean, size=size)


class Patient:
    '''Represents a patient.'''
    def __init__(self, p_id):
        self.id = p_id
        self.q_time_nurse = 0
        self.actual_time_with_nurse = 0


class Model:
    '''Simulation model for a clinic.'''
    def __init__(self, run_number):
        # Create SimPy environment
        self.env = simpy.Environment()

        self.patient_counter = 0
        self.patient_objects = []

        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)
        self.run_number = run_number

        # Create dataframe to store patient-level results
        self.results_df = pd.DataFrame()
        self.results_df['Patient ID'] = [1]
        self.results_df['Q Time Nurse'] = [0.0]
        self.results_df.set_index('Patient ID', inplace=True)

        # Attributes to store metrics
        self.mean_q_time_nurse = 0
        self.nurse_utilisation = 0.0
        self.utilisation_audit = []

        # Initialise distributions
        self.patient_inter_arrival_dist = Exponential(
            mean = g.patient_inter, random_seed = self.run_number*2)
        self.nurse_consult_time_dist = Exponential(
            mean = g.mean_n_consult_time, random_seed = self.run_number*4)

    def generator_patient_arrivals(self):
        '''Generates patient arrivals.''' 
        while True:
            self.patient_counter += 1
            # Create new patient
            p = Patient(self.patient_counter)
            # Save to patient_objects to use for auditing, if after warm-up
            if self.env.now > g.warm_up_period:
                self.patient_objects.append(p)
            # Start process of attending clinic
            self.env.process(self.attend_clinic(p))
            # Sample and pass time to next arrival
            sampled_inter = self.patient_inter_arrival_dist.sample()
            yield self.env.timeout(sampled_inter)

    def attend_clinic(self, patient):
        '''Simulates patient journey through the clinic.'''
        # Start queueing and request nurse resource
        start_q_nurse = self.env.now
        with self.nurse.request() as req:
            yield req

            # Record time spent waiting
            end_q_nurse = self.env.now
            patient.q_time_nurse = end_q_nurse - start_q_nurse

            # Sample time spent with nurse
            sampled_nurse_act_time = self.nurse_consult_time_dist.sample()

            # Only save results if the warm up period has passed
            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, 'Q Time Nurse'] = (
                    patient.q_time_nurse
                )
                self.results_df.at[patient.id, 'Time with Nurse'] = (
                    sampled_nurse_act_time)

                # In order to calculate nurse utilisation, also save this as a
                # patient attribute - but if consultation would overrun
                # simulation run time, then just use time to end of simulation
                remaining_time = (g.warm_up_period + g.sim_duration) - self.env.now
                patient.actual_time_with_nurse = min(
                    sampled_nurse_act_time, remaining_time)

            # Pass time spent with nurse
            yield self.env.timeout(sampled_nurse_act_time)

    def audit_utilisation(self, activity_attribute, resource_attribute):
        '''Calculate resource utilisation'''
        # Get duration of specified activity
        # (e.g. time each patient spent with nurse)
        activity_durations = [getattr(i, activity_attribute)
                              for i in self.patient_objects]
        # Get total capacity of specified resource
        # (number of resources * simulation time - which doesn't include warm up)
        total_capacity = getattr(g, resource_attribute) * g.sim_duration
        # Calculate and return utilisation
        return sum(activity_durations) / total_capacity

    def interval_audit_utilisation(self, resources, interval=1):
        '''
        Record resource utilisation at regular intervals.
        Need to pass to env.process.

        Parameters:
        -----------
            resource (SimPy resource or list of dicts): 
                - A SimPy resource object to monitor, OR 
                - A list of dictionaries in the format:
                [{'resource_name': 'name', 'resource_object': resource}]
            interval (int, optional): 
                Time between audits (default: 1).
        '''
        # TODO: Simplify this - am sure it should be possible to reduce duplication here?
        # TODO: This isn't accounting for warm-up?
        # Using SimPy resource attributes, can get number currently in use (count),
        # total resources in simulation (capacity), and number of entities
        # currently queueing for a resource (queue)
        while True:
            # If pass in a list of resources...
            if isinstance(resources, list):
                for i in range(len(resources)):
                    self.utilisation_audit.append({
                        'resource_name': resources[i]['resource_name'],
                        'simulation_time': self.env.now,
                        'number_utilised': len(resources[i]['resource_object'].count),
                        'number_available': resources[i]['resource_object'].capacity,
                        'queue_length': len(resources[i]['resource_object'].queue)
                    })
            # If pass in a single resource...
            else:
                self.utilisation_audit.append({
                    'simulation_time': self.env.now,
                    'number_utilised': resources.count, 
                    'number_available': resources.capacity,
                    'queue_length': len(resources.queue)
                })
            # Trigger next audit after desired interval has passed
            yield self.env.timeout(interval)

    def calculate_run_results(self):
        '''Calculates mean queuing time for the run.'''
        # WARM-UP: Remove dummy patient created when set up dataframe
        # TODO: Check if can set up in different way so not issue?
        self.results_df.drop([1], inplace=True)
        self.mean_q_time_nurse = self.results_df['Q Time Nurse'].mean()
        self.nurse_utilisation = self.audit_utilisation(
            activity_attribute='actual_time_with_nurse',
            resource_attribute='number_of_nurses')

    def run(self):
        '''Executes the simulation run.'''
        # Start patient generator
        self.env.process(self.generator_patient_arrivals())

        # Start interval auditor for nurse utilisation
        self.env.process(self.interval_audit_utilisation(
            resources=self.nurse, interval=g.audit_interval))

        # Run for specified duration + warm-up period
        self.env.run(until=(g.sim_duration + g.warm_up_period))

        # Tidy patient-level results and calculate averages
        self.calculate_run_results()

        # Return patient level results
        return (self.results_df)


class Trial:
    '''Manages multiple simulation runs.'''
    def __init__(self):
        self.patient_results_df = pd.DataFrame()
        self.trial_results_df = pd.DataFrame()
        self.interval_audit_df = pd.DataFrame()

    def run_single(self, run):
        '''Executes a single run of the model.'''
        random.seed(run)

        # Run model and save patient-level results, adding run number
        my_model = Model(run)
        patient_results = my_model.run()
        patient_results['run'] = run

        # Record trial-level results
        trial_results = {
            'Run Number': run,
            'scenario': g.scenario_name,
            'Arrivals': len(patient_results),
            'Mean Q Time Nurse': my_model.mean_q_time_nurse,
            'Average Nurse Utilisation': my_model.nurse_utilisation
        }

        # Collect interval audit results
        interval_audit_df = pd.DataFrame(my_model.utilisation_audit)
        interval_audit_df['run'] = run
        interval_audit_df['perc_utilisation'] = (
            interval_audit_df['number_utilised'] / interval_audit_df['number_available']
        )
        return {
            'patient': patient_results,
            'trial': trial_results,
            'interval_audit': interval_audit_df
        }

    def run_trial(self, cores=1):
        '''
        Execute trial with multiple runs
        Default 1 will run sequentially
        -1 means it will use every available core
        Otherwise can specify desired number
        '''
        # Sequential execution
        if cores == 1:
            all_results = [self.run_single(run) for run in range(g.number_of_runs)]
        # Parallel execution
        else:
            all_results = Parallel(n_jobs=cores)(
                delayed(self.run_single)(run) for run in range(g.number_of_runs))

        # Seperate results from each run into appropriate lists
        patient_results_list = [result['patient'] for result in all_results]
        trial_results_list = [result['trial'] for result in all_results]
        interval_audit_list = [result['interval_audit'] for result in all_results]

        # Convert lists into dataframes
        self.patient_results_df = pd.concat(patient_results_list, ignore_index=True)
        self.trial_results_df = pd.DataFrame(trial_results_list)
        self.interval_audit_df = pd.concat(interval_audit_list, ignore_index=True)


my_trial = Trial()
my_trial.run_trial()

# Preview results
display(my_trial.patient_results_df)
display(my_trial.trial_results_df)
display(my_trial.interval_audit_df)

# Plot interval audit utilisation
fig = px.line(my_trial.interval_audit_df, x="simulation_time", y="perc_utilisation", color="run")
fig.show()

# Plot median utilisation
interval_audits_median = my_trial.interval_audit_df.groupby("simulation_time").median().reset_index()
fig = px.line(interval_audits_median, x="simulation_time", y="perc_utilisation")
fig.show()
```

```{python}
# Run with 1 to 14 cores
speed = []
g.number_of_runs = 100
for i in range(1, 15, 1):
    start_time = time.time()
    my_trial = Trial()
    my_trial.run_trial(cores=i)
    run_time = round((time.time() - start_time), 3)
    speed.append({'Cores':i, 'Run Time (seconds)': run_time})

# Display and plot time by number of cores
timing_results = pd.DataFrame(speed)
print(timing_results)
fig = px.line(timing_results, x='Cores', y='Run Time (seconds)')
fig.show()
```

```{python}
# TODO: Issue with this set-up is that you could unknowingly change g somewhere
# So here, for example, having to set g.number_of_runs back to a lower number
# Is there an alternative way of doing this that avoids that issue?
# For example, having those as inputs to Model() instead?

# Define a set of scenarios
g.number_of_runs = 5
scenarios = {
    'patient_inter': [5, 10, 15],
    'mean_n_consult_time': [15, 20, 35],
    'number_of_nurses': [3, 6, 9]
}

# Find every possible permutation of the scenarios
all_scenarios_tuples = [
    x for x in itertools.product(*scenarios.values())]
# Convert back into dictionaries
all_scenarios_dicts = [
    dict(zip(scenarios.keys(), p)) for p in all_scenarios_tuples]
# Preview some of the scenarios
print(f'There are {len(all_scenarios_dicts)} scenarios. For example:')
display(all_scenarios_dicts[0:6])

# Run the scenarios...
results = []
for index, scenario_to_run in enumerate(all_scenarios_dicts):
    # Overwrite defaults from the passed dictionary
    g.scenario_name = index
    for key in scenario_to_run:
        setattr(g, key, scenario_to_run[key])
    # Call the run trial method of our Trial object, and keep trial-level results
    my_trial = Trial()
    my_trial.run_trial()
    results.append(my_trial.trial_results_df)
# View mean results by scenario
display(pd.concat(results).drop('Run Number', axis=1).groupby('scenario').mean().head(20))

# TODO: Issue: warm-up patients use resources but their activity is excluded
# from metrics. Post-warm-up patients queue behind these, making it look
# like resources are under-utilised during the measurement period if there are
# long queues (e.g. due to really short inter-arrival times)
```