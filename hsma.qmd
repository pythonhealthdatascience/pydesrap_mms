---
title: "HSMA model"
---

This is from:

* <https://hsma-programme.github.io/hsma6_des_book/model_warm_up.html>.
* <https://hsma-programme.github.io/hsma6_des_book/priority_based_queueing.html>

That code was shared under an MIT Licence, with credit to: Sammi Rosser and Dan Chalk (2024) HSMA - the little book of DES (<https://github.com/hsma-programme/hsma6_des_book>).

```{python}
import numpy as np
import pandas as pd
import plotly.express as px
import random
import simpy

class g:
    '''Global parameters.'''
    patient_inter = 5
    mean_n_consult_time = 6
    number_of_nurses = 1

    # UNAVAILABLE: Nurse unavailable (e.g. 15m every 2h)
    unav_time_nurse = 15
    unav_freq_nurse = 120

    # Simulation
    sim_duration = 2880
    warm_up_period = 1440  # WARMUP - for no warm-up, set to 0
    number_of_runs = 3

class Exponential:
    '''Exponential distribution.'''
    def __init__(self, mean, random_seed = None):
        self.mean = mean
        self.rand = np.random.default_rng(random_seed)

    def sample(self, size = None):
        '''Generate sample.'''
        return self.rand.exponential(self.mean, size=size)

class Patient:
    '''Represents a patient.'''
    def __init__(self, p_id):
        self.id = p_id
        self.q_time_nurse = 0
        # PRIORITY: Lower value = higher priority.
        # This random samples - but would likely have probabilities for
        # particular patients.
        self.priority = random.randint(1,5)

class Model:
    '''Simulation model for a clinic.'''
    def __init__(self, run_number):
        self.env = simpy.Environment()
        self.patient_counter = 0

        # PRIORITY: Nurse is PriorityResource rather than Resource
        self.nurse = simpy.PriorityResource(self.env, capacity=g.number_of_nurses)
        self.run_number = run_number

        # Create dataframe to store patient-level results
        # PRIORITY: Include priority column
        self.results_df = pd.DataFrame()
        self.results_df['Patient ID'] = [1]
        self.results_df['Q Time Nurse'] = [0.0]
        self.results_df['Priority'] = [1]
        self.results_df.set_index('Patient ID', inplace=True)

        # Attribute to store mean queue times
        self.mean_q_time_nurse = 0

        # Initialise distributions
        self.patient_inter_arrival_dist = Exponential(
            mean = g.patient_inter, random_seed = self.run_number*2)
        self.nurse_consult_time_dist = Exponential(
            mean = g.mean_n_consult_time, random_seed = self.run_number*4)

    def generator_patient_arrivals(self):
        '''Generates patient arrivals.''' 
        while True:
            self.patient_counter += 1
            p = Patient(self.patient_counter)
            self.env.process(self.attend_clinic(p))
            sampled_inter = self.patient_inter_arrival_dist.sample()
            yield self.env.timeout(sampled_inter)

    # UNAVAILABLE:
    def obstruct_nurse(self):
        '''
        Obstructs nurse at specified intervals for specified amounts of time.
        '''
        while True:
            # Available
            yield self.env.timeout(g.unav_freq_nurse)
            # Using priority -1, takes nurse resource once finished with
            # current patient
            with self.nurse.request(priority=-1) as req:
                yield req
                # Unavailable
                yield self.env.timeout(g.unav_time_nurse)

    def attend_clinic(self, patient):
        '''Simulates patient journey through the clinic.'''
        start_q_nurse = self.env.now
        # PRIORITY: Pass priority to nurse
        with self.nurse.request(priority=patient.priority) as req:
            yield req
            end_q_nurse = self.env.now
            patient.q_time_nurse = end_q_nurse - start_q_nurse

            # WARM-UP: Only save results if the warm up period has passed
            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, 'Q Time Nurse'] = (
                    patient.q_time_nurse
                )
                # PRIORITY: Record patient priority
                self.results_df.at[patient.id, "Priority"] = (
                    patient.priority
                )

            sampled_nurse_act_time = self.nurse_consult_time_dist.sample()

            yield self.env.timeout(sampled_nurse_act_time)

    def calculate_run_results(self):
        '''Calculates mean queuing time for the run.'''
        # WARM-UP: Remove dummy patient created when set up dataframe
        self.results_df.drop([1], inplace=True)
        self.mean_q_time_nurse = self.results_df['Q Time Nurse'].mean()

    def run(self):
        '''Executes the simulation run.'''
        # Start patient generator
        self.env.process(self.generator_patient_arrivals())

        # UNAVAILABLE: Start obstructor generator
        self.env.process(self.obstruct_nurse())

        # WARM-UP: Run for specified duration + warm-up period
        self.env.run(until=(g.sim_duration + g.warm_up_period))

        # Tidy patient-level results and calculate averages
        self.calculate_run_results()

        # Return patient level results
        return (self.results_df)

class Trial:
    '''Manages multiple simulation runs.'''
    def __init__(self):
        self.df_trial_results = pd.DataFrame()
        self.df_trial_results['Run Number'] = [0]
        self.df_trial_results['Mean Q Time Nurse'] = [0.0]
        self.df_trial_results.set_index('Run Number', inplace=True)

    def calculate_means_over_trial(self):
        self.mean_q_time_nurse_trial = (
            self.df_trial_results['Mean Q Time Nurse'].mean()
        )

    def run_trial(self):
        '''Executes a trial with multiple runs.'''
        results_dfs = []
        for run in range(g.number_of_runs):
            my_model = Model(run)
            patient_level_results = my_model.run()
            # print(self.df_trial_results)
            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]
            patient_level_results = patient_level_results.round(2)
            patient_level_results['run'] = run
            results_dfs.append(patient_level_results)
        all_results_patient_level = pd.concat(results_dfs)
        self.calculate_means_over_trial()
        return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial

    def print_trial_results(self):
        print('Trial Results')
        # Patient-level data
        # print (self.df_trial_results)
        print(f'Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes')

# Create an instance of the Trial class and run the trial
my_trial = Trial()
df_trial_results_warmup, all_results_patient_level_warmup, means_over_trial_warmup = my_trial.run_trial()

# Run version without warm-up
g.warm_up_period = 0
my_trial = Trial()
df_trial_results, all_results_patient_level, means_over_trial = my_trial.run_trial()

# Results without warm-up
display(all_results_patient_level.head())
display(df_trial_results.round(2).head())

# Results with warm-up
display(all_results_patient_level_warmup.head())
display(df_trial_results_warmup.round(2).head())

# Plot warm-up v.s. no warm-up
df_trial_results = df_trial_results.reset_index()
df_trial_results['Warm Up'] = 'No Warm Up'
df_trial_results_warmup = df_trial_results_warmup.reset_index()
df_trial_results_warmup['Warm Up'] = 'With Warm Up'
fig = px.histogram(
    pd.concat([df_trial_results, df_trial_results_warmup]).round(2).reset_index(),
    x='Warm Up',
    color='Run Number', y='Mean Q Time Nurse',
    barmode='group',
    title='Average Queue Times per Run - With and Without Warmups')
fig.show()

# Plot queue time by priority
fig = px.box(all_results_patient_level.reset_index(), x="Priority", y="Q Time Nurse", points="all")
fig.show()
```