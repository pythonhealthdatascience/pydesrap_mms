---
title: "HSMA model"
---

This is adapted from code that was shared under an MIT Licence, with credit to: Sammi Rosser and Dan Chalk (2024) HSMA - the little book of DES (<https://github.com/hsma-programme/hsma6_des_book>).

```{python}
import numpy as np
import pandas as pd
import plotly.express as px
import random
import simpy

class g:
    '''Global parameters.'''
    # Inter-arrival times
    patient_inter = 5

    # Activity times
    mean_n_consult_time = 35

    # Resource numbers
    number_of_nurses = 9

    # Simulation meta parameters
    sim_duration = 600
    warm_up_period = 200
    number_of_runs = 5
    audit_interval = 5


class Exponential:
    '''Exponential distribution.'''
    def __init__(self, mean, random_seed = None):
        self.mean = mean
        self.rand = np.random.default_rng(random_seed)

    def sample(self, size = None):
        '''Generate sample.'''
        return self.rand.exponential(self.mean, size=size)

class Patient:
    '''Represents a patient.'''
    def __init__(self, p_id):
        self.id = p_id
        self.q_time_nurse = 0
        self.actual_time_with_nurse = 0

class Model:
    '''Simulation model for a clinic.'''
    def __init__(self, run_number):
        # Create SimPy environment
        self.env = simpy.Environment()

        self.patient_counter = 0
        self.patient_objects = []

        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)
        self.run_number = run_number

        # Create dataframe to store patient-level results
        self.results_df = pd.DataFrame()
        self.results_df['Patient ID'] = [1]
        self.results_df['Q Time Nurse'] = [0.0]
        self.results_df.set_index('Patient ID', inplace=True)

        # Attributes to store metrics
        self.mean_q_time_nurse = 0
        self.nurse_utilisation = 0.0
        self.utilisation_audit = []

        # Initialise distributions
        self.patient_inter_arrival_dist = Exponential(
            mean = g.patient_inter, random_seed = self.run_number*2)
        self.nurse_consult_time_dist = Exponential(
            mean = g.mean_n_consult_time, random_seed = self.run_number*4)

    def generator_patient_arrivals(self):
        '''Generates patient arrivals.''' 
        while True:
            self.patient_counter += 1
            # Create new patient
            p = Patient(self.patient_counter)
            # Save to patient_objects to use for auditing, if after warm-up
            if self.env.now > g.warm_up_period:
                self.patient_objects.append(p)
            # Start process of attending clinic
            self.env.process(self.attend_clinic(p))
            # Sample and pass time to next arrival
            sampled_inter = self.patient_inter_arrival_dist.sample()
            yield self.env.timeout(sampled_inter)

    def attend_clinic(self, patient):
        '''Simulates patient journey through the clinic.'''
        # Start queueing and request nurse resource
        start_q_nurse = self.env.now
        with self.nurse.request() as req:
            yield req

            # Record time spent waiting
            end_q_nurse = self.env.now
            patient.q_time_nurse = end_q_nurse - start_q_nurse

            # Sample time spent with nurse
            sampled_nurse_act_time = self.nurse_consult_time_dist.sample()

            # Only save results if the warm up period has passed
            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, 'Q Time Nurse'] = (
                    patient.q_time_nurse
                )
                self.results_df.at[patient.id, 'Time with Nurse'] = (
                    sampled_nurse_act_time)

                # In order to calculate nurse utilisation, also save this as a
                # patient attribute - but if consultation would overrun
                # simulation run time, then just use time to end of simulation
                remaining_time = (g.warm_up_period + g.sim_duration) - self.env.now
                patient.actual_time_with_nurse = min(
                    sampled_nurse_act_time, remaining_time)

            # Pass time spent with nurse
            yield self.env.timeout(sampled_nurse_act_time)

    def audit_utilisation(self, activity_attribute, resource_attribute):
        '''Calculate resource utilisation'''
        # Get duration of specified activity
        # (e.g. time each patient spent with nurse)
        activity_durations = [getattr(i, activity_attribute)
                              for i in self.patient_objects]
        # Get total capacity of specified resource
        # (number of resources * simulation time - which doesn't include warm up)
        total_capacity = getattr(g, resource_attribute) * g.sim_duration
        # Calculate and return utilisation
        return sum(activity_durations) / total_capacity

    def interval_audit_utilisation(self, resources, interval=1):
        '''
        Record resource utilisation at regular intervals.
        Need to pass to env.process.

        Parameters:
        -----------
            resource (SimPy resource or list of dicts): 
                - A SimPy resource object to monitor, OR 
                - A list of dictionaries in the format:
                [{'resource_name': 'name', 'resource_object': resource}]
            interval (int, optional): 
                Time between audits (default: 1).
        '''
        # TODO: Simplify this - am sure it should be possible to reduce duplication here?
        # Using SimPy resource attributes, can get number currently in use (count),
        # total resources in simulation (capacity), and number of entities
        # currently queueing for a resource (queue)
        while True:
            # If pass in a list of resources...
            if isinstance(resources, list):
                for i in range(len(resources)):
                    self.utilisation_audit.append({
                        'resource_name': resources[i]['resource_name'],
                        'simulation_time': self.env.now,
                        'number_utilised': len(resources[i]['resource_object'].count),
                        'number_available': resources[i]['resource_object'].capacity,
                        'queue_length': len(resources[i]['resource_object'].queue)
                    })
            # If pass in a single resource...
            else:
                self.utilisation_audit.append({
                    'simulation_time': self.env.now,
                    'number_utilised': resources.count, 
                    'number_available': resources.capacity,
                    'queue_length': len(resources.queue)
                })
            # Trigger next audit after desired interval has passed
            yield self.env.timeout(interval)

    def calculate_run_results(self):
        '''Calculates mean queuing time for the run.'''
        # WARM-UP: Remove dummy patient created when set up dataframe
        # TODO: Check if can set up in different way so not issue?
        self.results_df.drop([1], inplace=True)
        self.mean_q_time_nurse = self.results_df['Q Time Nurse'].mean()
        self.nurse_utilisation = self.audit_utilisation(
            activity_attribute='actual_time_with_nurse',
            resource_attribute='number_of_nurses')

    def run(self):
        '''Executes the simulation run.'''
        # Start patient generator
        self.env.process(self.generator_patient_arrivals())

        # Start interval auditor for nurse utilisation
        self.env.process(self.interval_audit_utilisation(
            resources=self.nurse, interval=g.audit_interval))

        # Run for specified duration + warm-up period
        self.env.run(until=(g.sim_duration + g.warm_up_period))

        # Tidy patient-level results and calculate averages
        self.calculate_run_results()

        # Return patient level results
        return (self.results_df)

class Trial:
    '''Manages multiple simulation runs.'''
    def __init__(self):
        self.df_trial_results = pd.DataFrame()
        self.df_trial_results['Run Number'] = [0]
        self.df_trial_results['Mean Q Time Nurse'] = [0.0]
        self.df_trial_results['Average Nurse Utilisation'] = [0.0]
        self.df_trial_results.set_index('Run Number', inplace=True)
        self.interval_audit_list = []

    def calculate_means_over_trial(self):
        self.mean_q_time_nurse_trial = (
            self.df_trial_results['Mean Q Time Nurse'].mean()
        )

    def run_trial(self):
        '''Executes a trial with multiple runs.'''
        results_dfs = []

        # For specified number of replications
        for run in range(g.number_of_runs):
    
            # Run model
            my_model = Model(run)
            patient_level_results = my_model.run()
    
            # print(self.df_trial_results)

            # Record trial-level results
            self.df_trial_results.loc[run, 'Mean Q Time Nurse'] = [my_model.mean_q_time_nurse]
            self.df_trial_results.loc[run, 'Average Nurse Utilisation'] = [my_model.nurse_utilisation]

            # Record interval audit results
            interval_audit_df = pd.DataFrame(my_model.utilisation_audit)
            interval_audit_df['run'] = run
            interval_audit_df['perc_utilisation'] = (
              interval_audit_df['number_utilised'] / interval_audit_df['number_available']
            )
            self.interval_audit_list.append(interval_audit_df)

            # Tidy patient level-results and append to list
            patient_level_results = patient_level_results.round(2)
            patient_level_results['run'] = run
            results_dfs.append(patient_level_results)

        # Convert patient-level results to dataframe
        all_results_patient_level = pd.concat(results_dfs)

        # Calculate mean times
        self.calculate_means_over_trial()

        # Return trial-level results, patient-level results and mean queue time for nurse
        return (self.df_trial_results,
                all_results_patient_level,
                self.mean_q_time_nurse_trial)

    def print_trial_results(self):
        print('Trial Results')
        # Patient-level data
        # print (self.df_trial_results)
        print(f'Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes')

    def get_interval_audits(self):
        '''Join interval audits into a single dataframe'''
        return pd.concat(self.interval_audit_list)


# Create an instance of the Trial class and run the trial
my_trial = Trial()
df_trial_results_warmup, all_results_patient_level_warmup, means_over_trial_warmup = my_trial.run_trial()
interval_audits = my_trial.get_interval_audits()

my_trial.print_trial_results()

display(all_results_patient_level_warmup.head())
display(df_trial_results_warmup.round(2).head())
display(interval_audits.head())

# Plot interval audit utilisation
fig = px.line(interval_audits, x="simulation_time", y="perc_utilisation", color="run")
fig.show()

# Plot median utilisation
interval_audits_median = interval_audits.groupby("simulation_time").median().reset_index()
fig = px.line(interval_audits_median, x="simulation_time", y="perc_utilisation")
fig.show()
```